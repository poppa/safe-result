<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>safe-result</title>
	<meta name="description" content="Documentation for safe-result">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.json" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">safe-result</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1>safe-result</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<a href="#safe-result" id="safe-result" style="color: inherit; text-decoration: none;">
					<h1>safe-result</h1>
				</a>
				<p>One of the more challenging things in software development is error handling.
					When should an error be throw? When should it be caught? Should I catch it
					silently and return &quot;<code>undefined</code>&quot;? But if I do that someone higher up the
				callstack might want to get hold of the error for logging and what not.</p>
				<p>The purpose of this library is trying to make this a bit more coherent.
					Languages like Rust and Go have built-in mechanisms to make error handling a
					bit more concise and coherent than using <code>try / catch</code>, which imho litters the
				the code enormously.</p>
				<p>What more is, you often need to resort to using <code>let</code> instead of <code>const</code>
				just because you need to use the value after <code>try / catch</code>.</p>
				<p>The usecase for this library is to be used in you own library functions in your
					application. There really is no way around resorting to <code>try / catch</code> in
				Javascript, so you will have to use <code>try / catch</code> in your own &quot;low-level&quot; code.</p>
				<a href="#api" id="api" style="color: inherit; text-decoration: none;">
					<h2>API</h2>
				</a>
				<p><strong><a href="https://poppa.github.io/safe-result/">Full API documentation</a></strong></p>
				<p>You can either import the module via the default import</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> Result <span class="hljs-keyword">from</span> <span class="hljs-string">'safe-result'</span></code></pre>
				<p>or only import the methods you need</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> { success, failure } <span class="hljs-keyword">from</span> <span class="hljs-string">'safe-result'</span></code></pre>
				<ul>
					<li>
						<a href="#function-successlttgtvalue-t-successresultlttgt" id="function-successlttgtvalue-t-successresultlttgt" style="color: inherit; text-decoration: none;">
							<h4><code>function success&lt;T&gt;(value: T): SuccessResult&lt;T&gt;</code></h4>
						</a>
						<p>Method for creating a successful result.</p>
					</li>
					<li>
						<a href="#function-failurelttgterror-t-failureresultlttgt" id="function-failurelttgterror-t-failureresultlttgt" style="color: inherit; text-decoration: none;">
							<h4><code>function failure&lt;T&gt;(error: T): FailureResult&lt;T&gt;</code></h4>
						</a>
						<p>Method for creating a failed result.</p>
					</li>
					<li>
						<a href="#type-resultltt--unknown-e--errorgt--successresultlttgt--failureresultltegt" id="type-resultltt--unknown-e--errorgt--successresultlttgt--failureresultltegt" style="color: inherit; text-decoration: none;">
							<h4><code>type Result&lt;T = unknown, E = Error&gt; = SuccessResult&lt;T&gt; | FailureResult&lt;E&gt;</code></h4>
						</a>
						<p>Type that can be used as return type in methods returning either a
						<code>SuccessResult</code> or <code>FailureResult</code>.</p>
						<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">ok: <span class="hljs-built_in">boolean</span></span>): <span class="hljs-title">Result</span>&lt;</span>{ name: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> }&gt; {
  <span class="hljs-keyword">return</span> ok
    ? success({ name: <span class="hljs-string">'John Doe'</span>, age: <span class="hljs-number">54</span> })
    : failure(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Bad'</span>))
}</code></pre>
					</li>
					<li>
						<a href="#type-asyncresultltt--unknown-e--errorgt--promiseltresultltt-egtgt" id="type-asyncresultltt--unknown-e--errorgt--promiseltresultltt-egtgt" style="color: inherit; text-decoration: none;">
							<h4><code>type AsyncResult&lt;T = unknown, E = Error&gt; = Promise&lt;Result&lt;T, E&gt;&gt;</code></h4>
						</a>
						<p>Same as writing <code>Promise&lt;Result&lt;T, E&gt;&gt;</code>.</p>
					</li>
					<li>
						<a href="#async-function-alllttgtvalues-t--promiselikelttgt-promiseltresultlttgtgt" id="async-function-alllttgtvalues-t--promiselikelttgt-promiseltresultlttgtgt" style="color: inherit; text-decoration: none;">
							<h4><code>async function all&lt;T&gt;(values: (T | PromiseLike&lt;T&gt;)[]): Promise&lt;Result&lt;T[]&gt;&gt;</code></h4>
						</a>
						<p>Behaves like <code>Promise.all()</code> except it doesn&#39;t throw. If all values are
							resolved this promise will resolve to a <code>SuccessResult</code> where the <code>result</code>
						property is an array of the resolved values.</p>
						<p>If one value fails, this promise will immediately resolve to a
							<code>FailureResult</code> where the <code>error</code> property is the error from the rejected
						promise.</p>
					</li>
					<li>
						<a href="#async-function-allsetteledlttgtvalues-arrayltt--promiselttgtgt-promiseltsuccessandfailureresultltt-errorgtgt" id="async-function-allsetteledlttgtvalues-arrayltt--promiselttgtgt-promiseltsuccessandfailureresultltt-errorgtgt" style="color: inherit; text-decoration: none;">
							<h4><code>async function allSetteled&lt;T&gt;(values: Array&lt;T | Promise&lt;T&gt;&gt;): Promise&lt;SuccessAndFailureResult&lt;T[], Error[]&gt;&gt;</code></h4>
						</a>
						<p>Just like <code>Promise.allSettled()</code> this will wait for all values to either
							resolve or reject. This will always return a <code>SuccessAndFailureResult</code>
						instance where both the <code>result</code> and <code>error</code> properties can be &quot;truthy&quot;.</p>
					</li>
					<li>
						<a href="#interface-resulttype" id="interface-resulttype" style="color: inherit; text-decoration: none;">
							<h4><code>interface ResultType</code></h4>
						</a>
						<p>Both <code>SuccessResult</code>, <code>FailureResult</code> and <code>SuccessAndFailureResult</code> implements
						this interface.</p>
						<ul>
							<li><p><strong><code>ResultType.result</code></strong> Property of the successful value</p>
							</li>
							<li><p><strong><code>ResultType.error</code></strong> Property of the failed value</p>
							</li>
							<li><p><strong><code>ResultType.unwrap(): [successValue, failValue]</code></strong> Returns a tuple where
									the first index is the successful value and the second the failed value.
									For a <code>SuccessResult</code> this is always <code>[successfulValue, undefined]</code>, and
								for a <code>FailureResult</code> it&#39;s always <code>[undefined, failedValue]</code>.</p>
								<p>The <code>SuccessAndFailureResult</code> returned from <code>allSetteled()</code> will always
									be a <code>[[...successfulValues], [...failedValues]]</code> tuple, so neither index
								will be <code>undefined</code>, but can be an array of length <code>0</code>.</p>
							</li>
							<li><p><strong><code>ResultType.success</code></strong> If <code>true</code> it&#39;s a successful value</p>
							</li>
							<li><p><strong><code>ResultType.failure</code></strong> If <code>true</code> it&#39;s a failed value</p>
								<p>For <code>SuccessResult</code> and <code>FailureResult</code> the <code>success</code> and <code>failure</code>
								properties are mutually exclusive.</p>
							</li>
						</ul>
					</li>
				</ul>
				<a href="#examples" id="examples" style="color: inherit; text-decoration: none;">
					<h2>Examples</h2>
				</a>
				<a href="#single-values" id="single-values" style="color: inherit; text-decoration: none;">
					<h3>Single values</h3>
				</a>
				<p>A single successful value is represented by an instance of <code>SuccessResult</code>.
				A single failed value is represented by an instance of <code>FailureResult</code>.</p>
				<p>Instances of these classes can be created by calling <code>success(okValue)</code> and
				<code>failure(Error)</code> respectively.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> Result <span class="hljs-keyword">from</span> <span class="hljs-string">'safe-result'</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unsafeMethod</span>(<span class="hljs-params"></span>): <span class="hljs-title">Result</span>&lt;</span>{ name: <span class="hljs-built_in">string</span>; age: <span class="hljs-built_in">number</span> }&gt; {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">return</span> Result.success(callToMethodThatMightThrow())
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-keyword">return</span> Result.failure(e)
  }
}

<span class="hljs-comment">// Method one</span>
<span class="hljs-keyword">const</span> r1 = unsafeMethod()

<span class="hljs-keyword">if</span> (r1.success) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Got OK result'</span>, r1.result) <span class="hljs-comment">// {name: 'Some string', age: x}</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Got failed result:'</span>, r1.error) <span class="hljs-comment">// Error('some error')</span>
}

<span class="hljs-comment">// Method 2</span>
<span class="hljs-keyword">const</span> [result, error] = unsafeMethod().unwrap()

<span class="hljs-keyword">if</span> (error) {
  <span class="hljs-built_in">console</span>.error(error)
  <span class="hljs-keyword">return</span>
}

<span class="hljs-comment">// See https://github.com/poppa/safe-result/issues/3</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Unfortunately it isn't safe to index `result` here according to Typescript.</span>
<span class="hljs-comment">// One would assume that we can be pretty sure that `result` is not undefined</span>
<span class="hljs-comment">// here, but I haven't figured out yet how to make TS acknowledge that the</span>
<span class="hljs-comment">// result and error values are mutually exclusive.</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name:`</span>, result.name)

<span class="hljs-comment">// Either resort to optional chaining</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name:`</span>, result?.name)

<span class="hljs-comment">// Or an if-statement (which one of the intentions of this lib is to not to</span>
<span class="hljs-comment">// have to do)</span>
<span class="hljs-keyword">if</span> (result) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Name:`</span>, result.name)
}</code></pre>
				<a href="#async-collections" id="async-collections" style="color: inherit; text-decoration: none;">
					<h3>Async collections</h3>
				</a>
				<a href="#resultall" id="resultall" style="color: inherit; text-decoration: none;">
					<h4><code>Result.all()</code></h4>
				</a>
				<p><code>safe-result</code> sort of implements <code>Promise.all()</code>, except it doesn&#39;t throw when
					a value is rejected. Instead you get back a <code>FailureResult</code> on error and a
				<code>SuccessResult</code> if all promises were resovled.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">import</span> Result, { success, failure } <span class="hljs-keyword">from</span> <span class="hljs-string">'safe-result'</span>

<span class="hljs-keyword">const</span> args = [<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>), <span class="hljs-built_in">Promise</span>.resovle(<span class="hljs-number">2</span>)]
<span class="hljs-keyword">const</span> [r1, e1] = (<span class="hljs-keyword">await</span> Result.all(args)).unwrap()

<span class="hljs-keyword">if</span> (e1) {
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">`An error occured:`</span>, e1.message)
  <span class="hljs-keyword">return</span>
}

<span class="hljs-built_in">console</span>.log(r1) <span class="hljs-comment">// [1, 2]</span></code></pre>
				<p><strong>Note:</strong> <code>Result.all()</code> doesn&#39;t neccessarily have to be given <code>Promises</code> or
					<code>Promise&lt;Result&gt;</code>-objects as arguments. If an argument isn&#39;t a promise, one
				will be created.</p>
				<p><strong>Note:</strong> If the value array given to <code>Result.all()</code> are of different types
					you have to explicitly state the types of elements in the array argument for
					the type inference of the result to be correct. This however is no different
				from how <code>Promise.all()</code> behaves.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> args: <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">number</span> | <span class="hljs-built_in">string</span>&gt;[] = [
  <span class="hljs-built_in">Promise</span>.resovle(<span class="hljs-number">1</span>),
  <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'two'</span>),
]

<span class="hljs-keyword">const</span> [res] = (<span class="hljs-keyword">await</span> Result.all(args)).unwrap()

<span class="hljs-keyword">if</span> (res) {
  <span class="hljs-comment">// Infered type of `res` here will be `Array&lt;string | number&gt;`</span>
}</code></pre>
				<p>...</p>
				<a href="#resultallsettled" id="resultallsettled" style="color: inherit; text-decoration: none;">
					<h4><code>Result.allSettled()</code></h4>
				</a>
				<p>This works pretty much the same as <code>Promise.allSettled()</code> except you get back
					a <code>SuccessAndFailureResult</code> instance. The way this differs from the
					<code>SuccessResult</code> and <code>FailureResult</code> classes is that this can be both a success
				and a failure at the same time.</p>
				<pre><code class="language-ts"><span class="hljs-keyword">const</span> args = [<span class="hljs-built_in">Promise</span>.resovle(<span class="hljs-number">1</span>), <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Fail'</span>))]

<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Result.allSettled(args)

<span class="hljs-keyword">if</span> (res.success) {
  <span class="hljs-comment">// Will be true in this case</span>
  <span class="hljs-comment">// res.result -&gt; [1]</span>
}

<span class="hljs-keyword">if</span> (res.failure) {
  <span class="hljs-comment">// Will also be true in this case</span>
  <span class="hljs-comment">// res.error -&gt; [Error('Fail')]</span>
}

<span class="hljs-comment">// If you simply want to ignore eventual errors</span>

<span class="hljs-keyword">const</span> [res] = (<span class="hljs-keyword">await</span> Result.allSettled(args)).unwrap()</code></pre>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_collection_.html">&quot;collection&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_index_.html">&quot;index&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_result_.html">&quot;result&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_typeguards_.html">&quot;typeguards&quot;</a>
					</li>
					<li class=" tsd-kind-module">
						<a href="modules/_types_.html">&quot;types&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="https://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>